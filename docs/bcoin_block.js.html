<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: bcoin/block.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: bcoin/block.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * block.js - block object for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2016, Christopher Jeffrey (MIT License).
 * https://github.com/indutny/bcoin
 */

module.exports = function(bcoin) {

var bn = require('bn.js');
var utils = require('./utils');
var assert = utils.assert;
var constants = bcoin.protocol.constants;
var network = bcoin.protocol.network;
var BufferWriter = require('./writer');
var BufferReader = require('./reader');

/**
 * Represents a full block.
 * @exports Block
 * @constructor
 * @extends AbstractBlock
 * @param {NakedBlock} data
 * @property {String} type - "block" (inv type).
 * @property {Number} version - Block version. Note
 * that BCoin reads versions as unsigned despite
 * them being signed on the protocol level. This
 * number will never be negative.
 * @property {Hash} prevBlock - Previous block hash.
 * @property {Hash} merkleRoot - Merkle root hash.
 * @property {Number} ts - Timestamp.
 * @property {Number} bits
 * @property {Number} nonce
 * @property {Number} totalTX - Transaction count.
 * @property {Number} height - Block height (-1 if not in the chain).
 * @property {TX[]} txs - Transaction vector.
 * @property {Hash?} commitmentHash - Commitment hash for segwit.
 * @property {Buffer?} witnessNonce - Witness nonce for segwit.
 * @property {ReversedHash} rhash - Reversed block hash (uint256le).
 */

function Block(data) {
  var self = this;

  if (!(this instanceof Block))
    return new Block(data);

  bcoin.abstractblock.call(this, data);

  this.type = 'block';

  this._witnessSize = data._witnessSize || 0;

  this.txs = data.txs || [];

  this._cbHeight = null;

  this.txs = this.txs.map(function(data, i) {
    if (data instanceof bcoin.tx)
      return data;

    return bcoin.tx(data, self, i);
  });
}

utils.inherits(Block, bcoin.abstractblock);

/**
 * Serialize the block. Include witnesses if present.
 * @returns {Buffer}
 */

Block.prototype.render = function render() {
  return this.getRaw();
};

/**
 * Serialize the block, do not include witnesses.
 * @returns {Buffer}
 */

Block.prototype.renderNormal = function renderNormal() {
  return bcoin.protocol.framer.block(this);
};

/**
 * Serialize the block. Include witnesses if present.
 * @returns {Buffer}
 */

Block.prototype.renderWitness = function renderWitness() {
  return bcoin.protocol.framer.witnessBlock(this);
};

/**
 * Get the raw block serialization.
 * Include witnesses if present.
 * @returns {Buffer}
 */

Block.prototype.getRaw = function getRaw() {
  var raw;

  if (this.hasWitness())
    raw = bcoin.protocol.framer.witnessBlock(this);
  else
    raw = bcoin.protocol.framer.block(this);

  this._size = raw.length;
  this._witnessSize = raw._witnessSize;

  return raw;
};

Block.prototype._getSize = function _getSize() {
  var sizes = bcoin.protocol.framer.block.sizes(this);
  this._size = sizes.size;
  this._witnessSize = sizes.witnessSize;
};

/**
 * Calculate virtual block size.
 * @param {Boolean?} force - If true, always recalculate.
 * @returns {Number} Virtual size.
 */

Block.prototype.getVirtualSize = function getVirtualSize(force) {
  var size, witnessSize, base;

  size = this.getSize(force);
  witnessSize = this.getWitnessSize(force);
  base = size - witnessSize;

  return (base * 4 + witnessSize + 3) / 4 | 0;
};

/**
 * Get real block size.
 * @param {Boolean?} force - If true, always recalculate.
 * @returns {Number} size
 */

Block.prototype.getSize = function getSize(force) {
  if (force || this._size === 0)
    this._getSize();
  return this._size;
};

/**
 * Get the total size of the witnesses.
 * @param {Boolean?} force - If true, always recalculate.
 * @returns {Number} witness size
 */

Block.prototype.getWitnessSize = function getWitnessSize(force) {
  if (force || this._size === 0)
    this._getSize();
  return this._witnessSize;
};

/**
 * Test whether the block contains a
 * transaction with a non-empty witness.
 * @returns {Boolean}
 */

Block.prototype.hasWitness = function hasWitness() {
  for (var i = 0; i &lt; this.txs.length; i++) {
    if (this.txs[i].hasWitness())
      return true;
  }
  return false;
};

/**
 * Test the block's transaction vector against a hash.
 * @param {Hash|TX} hash
 * @returns {Boolean}
 */

Block.prototype.hasTX = function hasTX(hash) {
  return this.indexOf(hash) !== -1;
};

/**
 * Find the index of a transaction in the block.
 * @param {Hash|TX} hash
 * @returns {Number} index (-1 if not present).
 */

Block.prototype.indexOf = function indexOf(hash) {
  var i;

  if (hash instanceof bcoin.tx)
    hash = hash.hash('hex');

  for (i = 0; i &lt; this.txs.length; i++) {
    if (this.txs[i].hash('hex') === hash)
      return i;
  }

  return -1;
};

/**
 * Count sigops taking into account the cost vs. witness ops.
 * @param {Boolean?} scriptHash - Whether to count redeem script ops.
 * @param {Boolean?} accurate - Whether to use accurate counting
 * for CHECKMULTISIG(VERIFY).
 * @returns {Number} sigops
 */

Block.prototype.getSigops = function getSigops(scriptHash, accurate) {
  var total = 0;
  var i;

  for (i = 0; i &lt; this.txs.length; i++)
    total += this.txs[i].getSigops(scriptHash, accurate);

  return total;
};

/**
 * Calculate merkle root.
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Buffer|Hash} hash
 */

Block.prototype.getMerkleRoot = function getMerkleRoot(enc) {
  var leaves = [];
  var i, root;

  for (i = 0; i &lt; this.txs.length; i++)
    leaves.push(this.txs[i].hash());

  root = utils.getMerkleRoot(leaves);

  if (!root)
    return;

  return enc === 'hex'
    ? root.toString('hex')
    : root;
};

/**
 * Calculate commitment hash (the root of the
 * witness merkle tree hashed with the witnessNonce).
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Buffer|Hash} hash
 */

Block.prototype.getCommitmentHash = function getCommitmentHash(enc) {
  var leaves = [];
  var witnessNonce = this.witnessNonce;
  var i, witnessRoot, commitmentHash;

  if (!witnessNonce)
    return;

  for (i = 0; i &lt; this.txs.length; i++)
    leaves.push(this.txs[i].witnessHash());

  witnessRoot = utils.getMerkleRoot(leaves);

  if (!witnessRoot)
    return;

  commitmentHash = utils.dsha256(Buffer.concat([witnessRoot, witnessNonce]));

  return enc === 'hex'
    ? commitmentHash.toString('hex')
    : commitmentHash;
};

Block.prototype.__defineGetter__('witnessNonce', function() {
  var coinbase = this.txs[0];

  if (!coinbase)
    return;

  if (coinbase.inputs.length !== 1)
    return;

  if (coinbase.inputs[0].witness.items.length !== 1)
    return;

  if (coinbase.inputs[0].witness.items[0].length !== 32)
    return;

  return coinbase.inputs[0].witness.items[0];
});

Block.prototype.__defineGetter__('commitmentHash', function() {
  var coinbase, i, commitment, commitmentHash;

  if (this._commitmentHash)
    return this._commitmentHash;

  coinbase = this.txs[0];

  if (!coinbase)
    return;

  for (i = 0; i &lt; coinbase.outputs.length; i++) {
    commitment = coinbase.outputs[i].script;
    if (commitment.isCommitment()) {
      commitmentHash = commitment.getCommitmentHash();
      break;
    }
  }

  if (commitmentHash)
    this._commitmentHash = commitmentHash.toString('hex');

  return this._commitmentHash;
});

/**
 * Do non-contextual verification on the block. Including checking the block
 * size, the coinbase and the merkle root. This is consensus-critical.
 * @alias verify
 * @param {Object?} ret - Return object, may be
 * set with properties `reason` and `score`.
 * @returns {Boolean}
 */

Block.prototype._verify = function _verify(ret) {
  var sigops = 0;
  var i, tx, merkle;

  if (!ret)
    ret = {};

  if (!this.verifyHeaders(ret))
    return false;

  // Size can't be bigger than MAX_BLOCK_SIZE
  if (this.txs.length > constants.block.MAX_SIZE
      || this.getVirtualSize() > constants.block.MAX_SIZE) {
    ret.reason = 'bad-blk-length';
    ret.score = 100;
    return false;
  }

  // First TX must be a coinbase
  if (this.txs.length === 0 || !this.txs[0].isCoinbase()) {
    ret.reason = 'bad-cb-missing';
    ret.score = 100;
    return false;
  }

  // Test all txs
  for (i = 0; i &lt; this.txs.length; i++) {
    tx = this.txs[i];

    // The rest of the txs must not be coinbases
    if (i > 0 &amp;&amp; tx.isCoinbase()) {
      ret.reason = 'bad-cb-multiple';
      ret.score = 100;
      return false;
    }

    // Sanity checks
    if (!tx.isSane(ret))
      return false;

    // Count legacy sigops (do not count scripthash or witness)
    // sigops += tx._getSigops();
    // if (sigops > constants.block.MAX_SIGOPS) {
    //   return callback(new VerifyError(block,
    //     'invalid',
    //     'bad-blk-sigops',
    //     100));
    // }
  }

  // Check merkle root
  merkle = this.getMerkleRoot('hex');

  // If the merkle is mutated,
  // we have duplicate txs.
  if (!merkle) {
    ret.reason = 'bad-txns-duplicate';
    ret.score = 100;
    return false;
  }

  if (this.merkleRoot !== merkle) {
    ret.reason = 'bad-txnmrkleroot';
    ret.score = 100;
    return false;
  }

  return true;
};

/**
 * Retrieve the coinbase height from the coinbase input script.
 * @returns {Number} height (-1 if not present).
 */

Block.prototype.getCoinbaseHeight = function getCoinbaseHeight() {
  var coinbase, height;

  if (this.version &lt; 2)
    return -1;

  if (this._cbHeight != null)
    return this._cbHeight;

  coinbase = this.txs[0];

  if (!coinbase || coinbase.inputs.length === 0)
    return -1;

  height = coinbase.inputs[0].script.getCoinbaseHeight();
  this._cbHeight = height;

  return height;
};

/**
 * Calculate the block reward.
 * @returns {BN} reward
 */

Block.prototype.getReward = function getReward() {
  var reward = Block.reward(this.height);
  var i;

  for (i = 1; i &lt; this.txs.length; i++)
    reward.iadd(this.txs[i].getFee());

  return reward;
};

/**
 * Get the "claimed" reward by the coinbase.
 * @returns {BN} claimed
 */

Block.prototype.getClaimed = function getClaimed() {
  assert(this.txs[0]);
  assert(this.txs[0].isCoinbase());
  return this.txs[0].getOutputValue();
};

/**
 * Calculate block subsidy.
 * @param {Number} height - Reward era by height.
 * @returns {BN}
 */

Block.reward = function reward(height) {
  var halvings = height / network.halvingInterval | 0;
  var reward;

  if (height &lt; 0)
    return new bn(0);

  if (halvings >= 64)
    return new bn(0);

  reward = new bn(5000000000);
  reward.iushrn(halvings);

  return reward;
};

/**
 * Get all unique outpoint hashes in the
 * block. Coinbases are ignored.
 * @returns {Hash[]} Outpoint hashes.
 */

Block.prototype.getPrevout = function getPrevout() {
  var prevout = {};
  var i, j, tx, input;

  for (i = 0; i &lt; this.txs.length; i++) {
    tx = this.txs[i];

    if (tx.isCoinbase())
      continue;

    for (j = 0; j &lt; tx.inputs.length; j++) {
      input = tx.inputs[j];
      prevout[input.prevout.hash] = true;
    }
  }

  return Object.keys(prevout);
};

/**
 * Inspect the block and return a more
 * user-friendly representation of the data.
 * @returns {Object}
 */

Block.prototype.inspect = function inspect() {
  return {
    type: this.type,
    height: this.height,
    hash: utils.revHex(this.hash('hex')),
    size: this.getSize(),
    virtualSize: this.getVirtualSize(),
    date: utils.date(this.ts),
    version: this.version,
    prevBlock: utils.revHex(this.prevBlock),
    merkleRoot: utils.revHex(this.merkleRoot),
    commitmentHash: this.commitmentHash
      ? utils.revHex(this.commitmentHash)
      : null,
    ts: this.ts,
    bits: this.bits,
    nonce: this.nonce,
    totalTX: this.totalTX,
    txs: this.txs
  };
};

/**
 * Convert the block to an object suitable
 * for JSON serialization. Note that the hashes
 * will be reversed to abide by bitcoind's legacy
 * of little-endian uint256s.
 * @returns {Object}
 */

Block.prototype.toJSON = function toJSON() {
  return {
    type: 'block',
    height: this.height,
    hash: utils.revHex(this.hash('hex')),
    version: this.version,
    prevBlock: utils.revHex(this.prevBlock),
    merkleRoot: utils.revHex(this.merkleRoot),
    ts: this.ts,
    bits: this.bits,
    nonce: this.nonce,
    totalTX: this.totalTX,
    txs: this.txs.map(function(tx) {
      return tx.toJSON();
    })
  };
};

/**
 * Handle a deserialized JSON transaction object.
 * @returns {Object} A "naked" block (a
 * plain javascript object which is suitable
 * for passing to the Block constructor).
 */

Block.parseJSON = function parseJSON(json) {
  assert.equal(json.type, 'block');
  json.prevBlock = utils.revHex(json.prevBlock);
  json.merkleRoot = utils.revHex(json.merkleRoot);
  json.txs = json.txs.map(function(tx) {
    return bcoin.tx.parseJSON(tx);
  });
  return json;
};

/**
 * Instantiate a block from a jsonified block object.
 * @param {Object} json - The jsonified block object.
 * @returns {Block}
 */

Block.fromJSON = function fromJSON(json) {
  return new Block(Block.parseJSON(json));
};

/**
 * Serialize the block.
 * @see {Block#render}
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @returns {Buffer|String}
 */

Block.prototype.toRaw = function toRaw(enc) {
  var data = this.render();

  if (enc === 'hex')
    data = data.toString('hex');

  return data;
};

/**
 * Parse a serialized block.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @param {String?} type - Can be `'block'`, `'merkleblock'`, or `'headers'`.
 * @returns {Object} A "naked" block object.
 */

Block.parseRaw = function parseRaw(data, enc, type) {
  if (enc === 'hex')
    data = new Buffer(data, 'hex');

  if (type === 'merkleblock')
    return bcoin.merkleblock.parseRaw(data);

  if (type === 'headers')
    return bcoin.headers.parseRaw(data);

  return bcoin.protocol.parser.parseBlock(data);
};

/**
 * Instantiate a block from a serialized Buffer.
 * @param {Buffer} data
 * @param {String?} enc - Encoding, can be `'hex'` or null.
 * @param {String?} type - Can be `'block'`, `'merkleblock'`, or `'headers'`.
 * @returns {Block}
 */

Block.fromRaw = function fromRaw(data, enc, type) {
  if (type === 'merkleblock')
    return bcoin.merkleblock.fromRaw(data, enc);

  if (type === 'headers')
    return bcoin.headers.fromRaw(data, enc);

  return new Block(Block.parseRaw(data, enc));
};

/**
 * Serialize a block to BCoin "compact format".
 * This is the serialization format BCoin uses internally
 * to store blocks in the database. It includes the height,
 * but does not include transaction data, only transaction
 * hashes.
 * @returns {Buffer}
 */

Block.prototype.toCompact = function toCompact() {
  var p = new BufferWriter();
  var height = this.height;

  if (height === -1)
    height = 0x7fffffff;

  p.writeBytes(this.abbr());
  p.writeU32(height);
  p.writeVarint(this.txs.length);

  this.txs.forEach(function(tx) {
    p.writeHash(tx.hash());
  });

  return p.render();
};

/**
 * Parse a transaction in "compact" serialization format.
 * @param {Buffer} buf
 * @returns {NakedBlock} - A "naked" block object with a `hashes` vector.
 */

Block.parseCompact = function parseCompact(buf) {
  var p = new BufferReader(buf);
  var hashes = [];
  var version = p.readU32(); // Technically signed
  var prevBlock = p.readHash('hex');
  var merkleRoot = p.readHash('hex');
  var ts = p.readU32();
  var bits = p.readU32();
  var nonce = p.readU32();
  var height = p.readU32();
  var txCount = p.readVarint();
  var i;

  for (i = 0; i &lt; txCount; i++)
    hashes.push(p.readHash('hex'));

  if (height === 0x7fffffff)
    height = -1;

  return {
    version: version,
    prevBlock: prevBlock,
    merkleRoot: merkleRoot,
    ts: ts,
    bits: bits,
    nonce: nonce,
    height: height,
    totalTX: txCount,
    hashes: hashes
  };
};

/**
 * Convert the Block to a MerkleBlock.
 * @param {Bloom} filter - Bloom filter for transactions
 * to match. The merkle block will contain only the
 * matched transactions.
 * @returns {MerkleBlock}
 */

Block.prototype.toMerkle = function toMerkle(filter) {
  return bcoin.merkleblock.fromBlock(this, filter);
};

/**
 * Test an object to see if it is a Block.
 * @param {Object} obj
 * @returns {Boolean}
 */

Block.isBlock = function isBlock(obj) {
  return obj
    &amp;&amp; typeof obj.merkleRoot === 'string'
    &amp;&amp; typeof obj.toCompact === 'function';
};

return Block;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-bcoin.html">bcoin</a></li><li><a href="module-constants.html">constants</a></li><li><a href="module-ec.html">ec</a></li><li><a href="module-ldb.html">ldb</a></li><li><a href="module-network.html">network</a></li><li><a href="module-profiler.html">profiler</a></li><li><a href="module-request.html">request</a></li><li><a href="module-utils.html">utils</a></li><li><a href="module-workers.html">workers</a></li></ul><h3>Classes</h3><ul><li><a href="AbstractBlock.html">AbstractBlock</a></li><li><a href="Address.html">Address</a></li><li><a href="Block.html">Block</a></li><li><a href="Bloom.html">Bloom</a></li><li><a href="BST.html">BST</a></li><li><a href="BufferReader.html">BufferReader</a></li><li><a href="BufferWriter.html">BufferWriter</a></li><li><a href="Chain.html">Chain</a></li><li><a href="ChainBlock.html">ChainBlock</a></li><li><a href="ChainDB.html">ChainDB</a></li><li><a href="Coin.html">Coin</a></li><li><a href="Coins.html">Coins</a></li><li><a href="CoinView.html">CoinView</a></li><li><a href="CompactBlock.html">CompactBlock</a></li><li><a href="Environment.html">Environment</a></li><li><a href="Framer.html">Framer</a></li><li><a href="Fullnode.html">Fullnode</a></li><li><a href="HD.html">HD</a></li><li><a href="HDPrivateKey.html">HDPrivateKey</a></li><li><a href="HDPublicKey.html">HDPublicKey</a></li><li><a href="HDSeed.html">HDSeed</a></li><li><a href="Headers.html">Headers</a></li><li><a href="HTTPBase.html">HTTPBase</a></li><li><a href="HTTPClient.html">HTTPClient</a></li><li><a href="HTTPProvider.html">HTTPProvider</a></li><li><a href="HTTPServer.html">HTTPServer</a></li><li><a href="Input.html">Input</a></li><li><a href="KeyPair.html">KeyPair</a></li><li><a href="LoadRequest.html">LoadRequest</a></li><li><a href="Locker.html">Locker</a></li><li><a href="LowlevelUp.html">LowlevelUp</a></li><li><a href="LRU.html">LRU</a></li><li><a href="Mempool.html">Mempool</a></li><li><a href="MerkleBlock.html">MerkleBlock</a></li><li><a href="Miner.html">Miner</a></li><li><a href="MinerBlock.html">MinerBlock</a></li><li><a href="MTX.html">MTX</a></li><li><a href="Node.html">Node</a></li><li><a href="Output.html">Output</a></li><li><a href="Parser.html">Parser</a></li><li><a href="Peer.html">Peer</a></li><li><a href="Pool.html">Pool</a></li><li><a href="Profile.html">Profile</a></li><li><a href="Provider.html">Provider</a></li><li><a href="Script.html">Script</a></li><li><a href="ScriptError.html">ScriptError</a></li><li><a href="Snapshot.html">Snapshot</a></li><li><a href="SPVNode.html">SPVNode</a></li><li><a href="Stack.html">Stack</a></li><li><a href="TimeData.html">TimeData</a></li><li><a href="TX.html">TX</a></li><li><a href="TXDB.html">TXDB</a></li><li><a href="VerifyError.html">VerifyError</a></li><li><a href="Wallet.html">Wallet</a></li><li><a href="WalletDB.html">WalletDB</a></li><li><a href="Witness.html">Witness</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Apr 20 2016 03:02:33 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
